import "jest-extended";

import { Container } from "@arkecosystem/core-kernel";
import Contracts, { Crypto, Identifiers } from "@arkecosystem/core-contracts";
import { Utils } from "@arkecosystem/crypto";

import { DynamicFeeMatcher } from "../../../packages/core-transaction-pool/source/dynamic-fee-matcher";
import {
	TransactionFeeToHighError,
	TransactionFeeToLowError,
} from "../../../packages/core-transaction-pool/source/errors";

const handler = { dynamicFee: jest.fn() };
const configuration = { getRequired: jest.fn() };
const handlerRegistry = { getActivatedHandlerForData: jest.fn() };
const stateStore = { getLastHeight: jest.fn() };
const logger = { debug: jest.fn(), notice: jest.fn() };

const container = new Container.Container();
container.bind(Identifiers.PluginConfiguration).toConstantValue(configuration);
container.bind(Identifiers.TransactionHandlerRegistry).toConstantValue(handlerRegistry);
container.bind(Identifiers.StateStore).toConstantValue(stateStore);
container.bind(Identifiers.LogService).toConstantValue(logger);

beforeEach(() => {
	handler.dynamicFee.mockReset();
	configuration.getRequired.mockReset();
	handlerRegistry.getActivatedHandlerForData.mockReset();
	stateStore.getLastHeight.mockReset();
	logger.debug.mockReset();
	logger.notice.mockReset();

	handlerRegistry.getActivatedHandlerForData.mockResolvedValue(handler);
});

describe("when dynamic fees are enabled", () => {
	const minFeePool = 500;
	const minFeeBroadcast = 501;
	const addonBytes = { transfer: 600 };
	const height = 100;

	beforeEach(() => {
		configuration.getRequired.mockReturnValueOnce({ enabled: true, minFeePool, minFeeBroadcast, addonBytes });
		stateStore.getLastHeight.mockReturnValueOnce(height);
		handler.dynamicFee.mockReturnValueOnce(new BigNumber(1000));
	});

	describe("DynamicFeeMatcher.throwIfCannotEnterPool", () => {
		it("should allow entering pool when fee is higher or equal than dynamic fee", async () => {
			const transaction = {
				key: "transfer",
				data: { fee: new BigNumber(1000) },
			} as Crypto.ITransaction;

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			const dynamicFeeContext: Contracts.Shared.DynamicFeeContext = {
				transaction,
				addonBytes: addonBytes.transfer,
				satoshiPerByte: minFeePool,
				height,
			};

			await expect(dynamicFeeMatcher.throwIfCannotEnterPool(transaction)).toResolve();

			expect(configuration.getRequired).toBeCalledWith("dynamicFees");
			expect(stateStore.getLastHeight).toBeCalled();
			expect(handler.dynamicFee).toBeCalledWith(dynamicFeeContext);
			expect(logger.debug).toBeCalled();
		});

		it("should not allow entering pool when fee is lower than dynamic fee", async () => {
			const transaction = {
				key: "transfer",
				data: { fee: new BigNumber(999) },
			} as Crypto.ITransaction;

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			const dynamicFeeContext: Contracts.Shared.DynamicFeeContext = {
				transaction,
				addonBytes: addonBytes.transfer,
				satoshiPerByte: minFeePool,
				height,
			};

			await expect(dynamicFeeMatcher.throwIfCannotEnterPool(transaction)).rejects.toThrowError(
				TransactionFeeToLowError,
			);

			expect(configuration.getRequired).toBeCalledWith("dynamicFees");
			expect(stateStore.getLastHeight).toBeCalled();
			expect(handler.dynamicFee).toBeCalledWith(dynamicFeeContext);
			expect(logger.notice).toBeCalled();
		});
	});

	describe("DynamicFeeMatcher.throwIfCannotBroadcast", () => {
		it("should allow broadcast when fee is higher or equal than dynamic fee", async () => {
			const transaction = {
				key: "transfer",
				data: { fee: new BigNumber(1000) },
			} as Crypto.ITransaction;

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			const dynamicFeeContext: Contracts.Shared.DynamicFeeContext = {
				transaction,
				addonBytes: addonBytes.transfer,
				satoshiPerByte: minFeeBroadcast,
				height,
			};

			await expect(dynamicFeeMatcher.throwIfCannotBroadcast(transaction)).toResolve();

			expect(configuration.getRequired).toBeCalledWith("dynamicFees");
			expect(stateStore.getLastHeight).toBeCalled();
			expect(handler.dynamicFee).toBeCalledWith(dynamicFeeContext);
			expect(logger.debug).toBeCalled();
		});

		it("should not allow broadcast when fee is lower than dynamic fee", async () => {
			const transaction = {
				key: "transfer",
				data: { fee: new BigNumber(999) },
			} as Crypto.ITransaction;

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(dynamicFeeMatcher.throwIfCannotBroadcast(transaction)).rejects.toThrowError(
				TransactionFeeToLowError,
			);
			const dynamicFeeContext: Contracts.Shared.DynamicFeeContext = {
				transaction,
				addonBytes: addonBytes.transfer,
				satoshiPerByte: minFeeBroadcast,
				height,
			};

			expect(configuration.getRequired).toBeCalledWith("dynamicFees");
			expect(stateStore.getLastHeight).toBeCalled();
			expect(handler.dynamicFee).toBeCalledWith(dynamicFeeContext);
			expect(logger.notice).toBeCalled();
		});
	});
});

describe("when dynamic fees are disabled", () => {
	beforeEach(() => {
		configuration.getRequired.mockReturnValueOnce({ enabled: false });
	});

	describe("DynamicFeeMatcher.throwIfCannotEnterPool", () => {
		it("should allow entering pool when fee equals static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(1000) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(dynamicFeeMatcher.throwIfCannotEnterPool(transaction as Crypto.ITransaction)).toResolve();

			expect(logger.debug).toBeCalled();
		});

		it("should not allow entering pool when fee is lower than static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(999) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(
				dynamicFeeMatcher.throwIfCannotEnterPool(transaction as Crypto.ITransaction),
			).rejects.toThrowError(TransactionFeeToLowError);

			expect(logger.notice).toBeCalled();
		});

		it("should not allow entering pool when fee is higher than static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(1001) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(
				dynamicFeeMatcher.throwIfCannotEnterPool(transaction as Crypto.ITransaction),
			).rejects.toThrowError(TransactionFeeToHighError);

			expect(logger.notice).toBeCalled();
		});
	});

	describe("DynamicFeeMatcher.throwIfCannotBroadcast", () => {
		it("should allow entering pool when fee equals static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(1000) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(dynamicFeeMatcher.throwIfCannotBroadcast(transaction as Crypto.ITransaction)).toResolve();

			expect(logger.debug).toBeCalled();
		});

		it("should not allow entering pool when fee is lower than static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(999) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(
				dynamicFeeMatcher.throwIfCannotBroadcast(transaction as Crypto.ITransaction),
			).rejects.toThrowError(TransactionFeeToLowError);

			expect(logger.notice).toBeCalled();
		});

		it("should not allow entering pool when fee is higher than static fee", async () => {
			const transaction = {
				key: "transfer",
				staticFee: new BigNumber(1000),
				data: { fee: new BigNumber(1001) },
			};

			const dynamicFeeMatcher = container.resolve(DynamicFeeMatcher);
			await expect(
				dynamicFeeMatcher.throwIfCannotBroadcast(transaction as Crypto.ITransaction),
			).rejects.toThrowError(TransactionFeeToHighError);

			expect(logger.notice).toBeCalled();
		});
	});
});
